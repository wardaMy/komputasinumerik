{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HALLO! Web berisikan tugas mata kuliah Komputasi Numerik dengan Dosen Pengampu Bapak Mula'ab, S.Si, M.Kom. Perkenalkan NAMA : WARDA MILANA MAYA NIM : 180411100155 `KELAS : KOMPUTASI NUMERIK A PRODI : TEKNIK INFORMATIKA","title":"HALLO!"},{"location":"#hallo","text":"Web berisikan tugas mata kuliah Komputasi Numerik dengan Dosen Pengampu Bapak Mula'ab, S.Si, M.Kom.","title":"HALLO!"},{"location":"#perkenalkan","text":"NAMA : WARDA MILANA MAYA NIM : 180411100155 `KELAS : KOMPUTASI NUMERIK A PRODI : TEKNIK INFORMATIKA","title":"Perkenalkan"},{"location":"1. McLaurin/","text":"DEFINISI? Deret MacLaurin merupakan suatu fungsi f(x) yang memiliki turunan f'(x), f\u201d(x), f\u201d'(x), dan seterusnya yang kontinyu dalam interval I dan a, x I maka untuk x disekitar a yaitu |x \u2013 a| < , f(x) dapat diekspansi kedalam Deret Taylor. Deret Maclaurin adalah bagian deret Taylor, dengan kata lain, deret Taylor yang berpusat di nol disebut dengan deret Maclaurin. Deret MacLaurin disebut juga Deret Taylor Baku. Berikut formulanya : TUGAS Mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 dengan listing program . Listing Program : import math x=4 ex=1 a=0 b=1 iter=1 while ex>0.001: f_x=0 f_y=0 for i in range (a): f_x += (2**i)*x**i/math.factorial(i) for j in range (b): f_y += (2**j)*x**j/math.factorial(j) ex=f_y-f_x a+=1 b+=1 print(\"iterasi ke-\",iter,\"= \",ex) iter+=1 output : iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"1. McLaurin"},{"location":"1. McLaurin/#definisi","text":"Deret MacLaurin merupakan suatu fungsi f(x) yang memiliki turunan f'(x), f\u201d(x), f\u201d'(x), dan seterusnya yang kontinyu dalam interval I dan a, x I maka untuk x disekitar a yaitu |x \u2013 a| < , f(x) dapat diekspansi kedalam Deret Taylor. Deret Maclaurin adalah bagian deret Taylor, dengan kata lain, deret Taylor yang berpusat di nol disebut dengan deret Maclaurin. Deret MacLaurin disebut juga Deret Taylor Baku. Berikut formulanya :","title":"DEFINISI?"},{"location":"1. McLaurin/#tugas","text":"Mengekspansi bilangan e^2x dengan nilai x=4 hingga nilai menjadi kurang dari 0,001 dengan listing program . Listing Program : import math x=4 ex=1 a=0 b=1 iter=1 while ex>0.001: f_x=0 f_y=0 for i in range (a): f_x += (2**i)*x**i/math.factorial(i) for j in range (b): f_y += (2**j)*x**j/math.factorial(j) ex=f_y-f_x a+=1 b+=1 print(\"iterasi ke-\",iter,\"= \",ex) iter+=1 output : iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"TUGAS"},{"location":"2. newton raphson/","text":"NEWTON RAPHSON adalah... Metode pendekatan yang menggunakan satu titik awal dn mendekatinya dengan memperhatikan slope atau gradien titik tersebut. Titik pendekatan ke n+1 dituliskan dengan : formulanya : Garis singgung terhadap fungsi pada Xn[yakni f'(Xn)] diekstrapolasikan kebawah terhadap sumbu x untuk memberikan sebuah taksiran akar pada Xn+1. ALGORITMA : 1.Definisikan fungsi f(x) dan f1(x) 2.Tentukan toleransi error (e) dan iterasi maksimum (n) 3.Tentukan nilai pendekatan awal Xo 4.Hitung f(Xo) dan f1(Xo) 5.Untuk iterasi I = 1 s/d n atau |f(xi)|e>= Hitung f(Xi) dan f1(Xi) 6.Akar persamaan adalah nilai xi yang terakhir diperoleh. Algoritma Metode Newton Raphson dengan modifikasi tabel : Definisikan fungsi F(x) ambil range nilai x = [a,b], dengan jumlah pembagi n Masukkan torelansi error (e) dan masukkan iterasi n Gunakan algoritma tabel diperoleh titik pendekatan awal Xo dari : F(Xk) . F(Xk+1)<0 maka Xo = Xk Hitung F(Xo) dan F1(Xo) Bila F( abs (F^1 (Xo))) < e, maka pendekatan awal Xo digeser sebesar dx Xo = Xo + dx hitung F(Xo) dan F1(Xo) Untuk iterasi I= 1 s/d n atau |F(xi)| e \u2265 hitung F(Xi) dan F1(xi) bila |F1(Xi)| < e maka \u200b Xi = Xi + dx hitung F(Xi) dan F1(Xo) Akar persamaan adalah x terakhir yang diperoleh. Dengan menggunakan algoritma Newton Raphson yang dimodifikasikan diharapkan akar yang diperoleh sesuai dengan harapan dan bila terdapat lebih dari satu akar dalam range ditunjuk, akan ditampilkan semuanya. PROGRAM #import math - untuk mengambil library matematika #Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f(x): function = (x**3) - (2*x) - 1 return function #berfungsi untuk menemukan turunan dari polinomial def derivative(x): h = 0.000001 derivative = (f(x + h) - f(x)) / h return derivative def newton_raphson(x): return (x - (f(x) / derivative(x))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def iterate(p, n): print(\"Banyak Iterasinya =\",n) x = p for i in range(n): x = newton_raphson(x) print(\"iterasi ke-\", i , \"=\", x) return (\"\") #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 20 iterasi dan ambil titik awal sebagai 1 print(iterate(1, 20)) hasil run : ```python Banyak Iterasinya = 20 iterasi ke- 0 = 2.999994000093219 iterasi ke- 1 = 2.199996832141079 iterasi ke- 2 = 1.7808294919560141 iterasi ke- 3 = 1.6363030634057565 iterasi ke- 4 = 1.618304588651506 iterasi ke- 5 = 1.6180340496697716 iterasi ke- 6 = 1.6180339887499484 iterasi ke- 7 = 1.6180339887498947 iterasi ke- 8 = 1.618033988749895 iterasi ke- 9 = 1.618033988749895 iterasi ke- 10 = 1.618033988749895 iterasi ke- 11 = 1.618033988749895 iterasi ke- 12 = 1.618033988749895 iterasi ke- 13 = 1.618033988749895 iterasi ke- 14 = 1.618033988749895 iterasi ke- 15 = 1.618033988749895 iterasi ke- 16 = 1.618033988749895 iterasi ke- 17 = 1.618033988749895 iterasi ke- 18 = 1.618033988749895 iterasi ke- 19 = 1.618033988749895 ```","title":"2. newton raphson"},{"location":"2. newton raphson/#newton-raphson-adalah","text":"Metode pendekatan yang menggunakan satu titik awal dn mendekatinya dengan memperhatikan slope atau gradien titik tersebut. Titik pendekatan ke n+1 dituliskan dengan : formulanya : Garis singgung terhadap fungsi pada Xn[yakni f'(Xn)] diekstrapolasikan kebawah terhadap sumbu x untuk memberikan sebuah taksiran akar pada Xn+1.","title":"NEWTON RAPHSON adalah..."},{"location":"2. newton raphson/#algoritma","text":"1.Definisikan fungsi f(x) dan f1(x) 2.Tentukan toleransi error (e) dan iterasi maksimum (n) 3.Tentukan nilai pendekatan awal Xo 4.Hitung f(Xo) dan f1(Xo) 5.Untuk iterasi I = 1 s/d n atau |f(xi)|e>= Hitung f(Xi) dan f1(Xi) 6.Akar persamaan adalah nilai xi yang terakhir diperoleh. Algoritma Metode Newton Raphson dengan modifikasi tabel : Definisikan fungsi F(x) ambil range nilai x = [a,b], dengan jumlah pembagi n Masukkan torelansi error (e) dan masukkan iterasi n Gunakan algoritma tabel diperoleh titik pendekatan awal Xo dari : F(Xk) . F(Xk+1)<0 maka Xo = Xk Hitung F(Xo) dan F1(Xo) Bila F( abs (F^1 (Xo))) < e, maka pendekatan awal Xo digeser sebesar dx Xo = Xo + dx hitung F(Xo) dan F1(Xo) Untuk iterasi I= 1 s/d n atau |F(xi)| e \u2265 hitung F(Xi) dan F1(xi) bila |F1(Xi)| < e maka \u200b Xi = Xi + dx hitung F(Xi) dan F1(Xo) Akar persamaan adalah x terakhir yang diperoleh. Dengan menggunakan algoritma Newton Raphson yang dimodifikasikan diharapkan akar yang diperoleh sesuai dengan harapan dan bila terdapat lebih dari satu akar dalam range ditunjuk, akan ditampilkan semuanya.","title":"ALGORITMA :"},{"location":"2. newton raphson/#program","text":"#import math - untuk mengambil library matematika #Program python untuk memperkirakan akar polinomial #menggunakan metode newton-raphson import math #f(x) - fungsi polynomial def f(x): function = (x**3) - (2*x) - 1 return function #berfungsi untuk menemukan turunan dari polinomial def derivative(x): h = 0.000001 derivative = (f(x + h) - f(x)) / h return derivative def newton_raphson(x): return (x - (f(x) / derivative(x))) # p - titik awal mis. nilai lebih dekat ke root # n - jmulah iterasi def iterate(p, n): print(\"Banyak Iterasinya =\",n) x = p for i in range(n): x = newton_raphson(x) print(\"iterasi ke-\", i , \"=\", x) return (\"\") #cetakan akar polinomial x ^ 3 - 2x - 1 menggunakan 20 iterasi dan ambil titik awal sebagai 1 print(iterate(1, 20)) hasil run : ```python Banyak Iterasinya = 20 iterasi ke- 0 = 2.999994000093219 iterasi ke- 1 = 2.199996832141079 iterasi ke- 2 = 1.7808294919560141 iterasi ke- 3 = 1.6363030634057565 iterasi ke- 4 = 1.618304588651506 iterasi ke- 5 = 1.6180340496697716 iterasi ke- 6 = 1.6180339887499484 iterasi ke- 7 = 1.6180339887498947 iterasi ke- 8 = 1.618033988749895 iterasi ke- 9 = 1.618033988749895 iterasi ke- 10 = 1.618033988749895 iterasi ke- 11 = 1.618033988749895 iterasi ke- 12 = 1.618033988749895 iterasi ke- 13 = 1.618033988749895 iterasi ke- 14 = 1.618033988749895 iterasi ke- 15 = 1.618033988749895 iterasi ke- 16 = 1.618033988749895 iterasi ke- 17 = 1.618033988749895 iterasi ke- 18 = 1.618033988749895 iterasi ke- 19 = 1.618033988749895 ```","title":"PROGRAM"},{"location":"3. MATERI 3/","text":"METODE GAUSS JORDAN PENGERTIAN Metode Gauss-Jordan merupakan suatu variasi dari Eliminasi Gauss dan dalam bahasa analitik biasanya lebih dikenal dengan nama reduksi baris. Perbedaan utamanya dengan eliminasi Gauss adalah bila sebuah yang tidak diketahui dieliminasikan dengan metode Gauss-Jordan maka ia deliminasikan dari setiap persamaan lainnya. Ini merupakan bentuk matrik kesatuan,padahal eliminasi Gauss merupakan matrik triangular. DASAR TEORI Penambahan Matrik sebelah kiri diubah menjadi matrik diagonal Penyelesaian dari persamaan linier simultan diatas adalah nilai d1,d2,d3,\u2026,dn dan atau x1 = d1,x2 = d2,x3=d3,\u2026.,xn=dn Teknik yang digunakan dalam metode eliminasi Gauss-Jordan ini sama seperti metode eliminasi Gauss yaitu menggunakan OBE (Operasi Baris Elementer). Hanya perhitungan penyelesaian secara langsung diperoleh dari nilai pada kolom terakhir dari setiap baris . Satu cara yang gamblang untuk menghitung inversi ialah dengan menggunakan metode Gauss-Jordan. Untuk melakukan ini,matriks koefisien diperluas dengan sebuah matriks kesatuan. Kemudian metode Gauss Jordan diterapkan agar mengurangi matriks koefisien menjadi sebuah matriks kesatuan. Jika ini telah selesai, ruas kanan matriks yang diperluas akan mengandung inversi CONTOH \u2022Selesaikan sistem persamaan : PROGRAM import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) hasil Run : Hasil 1: Masukkan ukuran Matrix: 3 Masukkan Nilai: 1 Masukkan Nilai: 1 Masukkan Nilai: 1 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 2 Masukkan Nilai: 2 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Hasil: 6 Masukkan Hasil: 2 Masukkan Hasil: 3 Matrix A : [[ 1. 1. 1. ] [ 0. -2. 1. ] [ 0. 0. -3.5]] Nilai X 3 = 2.0 Nilai X 2 = 3.0 Nilai X 1 = 1.0 METODE JACOB PENGERTIAN Metode [Iterasi] Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linear dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan [persamaan linear] berukuran besar dan proporsi koefisien nolnya besar. Kalau kita mengubah dalam Sistem Persamaan Linear, maka dapat ditulis sebagai berikut: Ax=b Kemudian, diketahui bahwa A =D + (L + U), di mana D merupakan matriks diagonal, L merupakan matriks segitiga bawah, dan U merupakan matriks segitiga atas. Kemudian, persamaan di atas dapat diubah menjadi: Dx + (L + U)x=b Kemudian, \u00d7 = D \u0304 \u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] Jika ditulis dalam aturan iteratif, maka metode Jacobi dapat ditulis sebagai: \u00d7\u207d\u1d4f\u207a\u00b9\u207e = D \u0304\u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] di mana k merupakan banyaknya iterasi. Jika \u00d7\u207d\u1d4f\u207e menyatakan hampiran ke-k penyelesaian SPL, maka \u00d7\u207d\u2070\u207e adalah hampiran awal. PROGRAM from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) HASI RUN contoh 1: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 3 Masukkan Nilai: 5 Masukkan Nilai: 7 Masukkan Nilai: 3 Masukkan Nilai: 5 Masukkan Nilai: 6 Masukkan Nilai: 3 Masukkan Hasil: 20 Masukkan Hasil: 18 Masukkan Hasil: 30 A: array([[2., 4., 3.], [5., 7., 3.], [5., 6., 3.]]) b: array([20., 18., 30.]) x: array([2.06506309e+10, 9.61264713e+09, 2.15123264e+10]) Cotoh 2: Masukkan ukuran Matrix: 2 Masukkan Nilai: 3 Masukkan Nilai: 6 Masukkan Nilai: 3 Masukkan Nilai: 8 Masukkan Hasil: 9 Masukkan Hasil: 16 A: array([[3., 6.], [3., 8.]]) b: array([ 9., 16.]) x: array([-3.77826554, 3.45248547]) METODE GAUSS SEIDEL PENGERTIAN Eliminasi Gauss seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai nilai yang berubah. Bilai diketahui peramaan linier simultan: KONSEP METODE GAUSS SEIDEL Hitung nilai xi untuk (i = 1 s/d n) proses iterasi dihentikan apabila bila selisih nilai xi (i = 1 s/d n ) dengan nilai xi pada iterasi sebelumnya kurang dari nilai toleransi error yang ditentukan ALGORITMA METODE GAUSS SEIDEL Masukkan matrik A , dan vektor B beserta ukuranya n. tentukan batas maksimum iterasi max_iter tentukkan toleransi error. tentukan nilai awal dari xi, untuk i =1 s/d n simpan xi dalam si, untuk i=1 s/d n untuk i=1 s/d n hitung iterasi <- iterasi +1 bila iterasi lebih dari max_iter atau tidak terdapat ei<\u03f5 untuk i=1 s/d n maka proses dihentikan dari penyelesaianya adalah xi untuk i=1 s/d n. Bila tidak maka ulangi langkah (5). PROGRAM def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) #print each time the updated solution print(x) Masukkan Panjang Matrix: 2 Masukkan a1,1: 2 Masukkan a1,2: 4 Masukkan Hasil: 3 Masukkan a2,1: 5 Masukkan a2,2: 3 Masukkan Hasil: 8 [0, 0, 0] [1.5, 0.16666666666666666, 0] [1.1666666666666667, 0.722222222222222, 0] [0.055555555555556024, 2.574074074074073, 0] [-3.648148148148146, 8.74691358024691, 0] [-15.993827160493819, 29.3230452674897, 0] [-57.1460905349794, 97.91015089163233, 0] [-194.32030178326465, 326.53383630544107, 0] [-651.5676726108821, 1088.6127876848036, 0] [-2175.725575369607, 3628.8759589493457, 0] [-7256.251917898691, 12096.419863164485, 0] [-24191.33972632897, 40321.566210548284, 0] [-80641.63242109657, 134405.38736849427, 0] [-268809.27473698853, 448018.1245616476, 0] [-896034.7491232952, 1493393.915205492, 0] [-2986786.330410984, 4977979.884018307, 0] [-9955958.268036613, 16593266.446727687, 0] [-33186531.393455375, 55310888.322425626, 0] [-110621775.14485125, 184369627.90808544, 0] [-368739254.3161709, 614565426.5269514, 0] [-1229130851.5539029, 2048551421.9231713, 0] [-4097102842.3463426, 6828504739.910571, 0] [-13657009478.321142, 22761682466.535236, 0] [-45523364931.57047, 75872274888.61745, 0] [-151744549775.7349, 252907582962.22482, 0] [-505815165922.94965, 843025276540.916, 0] [-1686050553080.332, 2810084255136.553, 0] [-5620168510271.606, 9366947517122.01, 0] [-18733895034242.52, 31223158390406.863, 0] [-62446316780812.23, 104077194634689.7, 0] [-208154389269377.9, 346923982115632.5, 0] [-693847964231263.5, 1156413273718775.2, 0] [-2312826547437549.0, 3854710912395917.5, 0] [-7709421824791834.0, 1.2849036374653058e+16, 0] [-2.5698072749306116e+16, 4.283012124884353e+16, 0] [-8.566024249768706e+16, 1.4276707082947842e+17, 0] [-2.8553414165895683e+17, 4.7589023609826144e+17, 0] [-9.517804721965229e+17, 1.5863007869942047e+18, 0] [-3.1726015739884093e+18, 5.287669289980682e+18, 0] [-1.0575338579961364e+19, 1.7625564299935607e+19, 0] [-3.5251128599871214e+19, 5.875188099978536e+19, 0] [-1.1750376199957071e+20, 1.9583960333261786e+20, 0] [-3.916792066652357e+20, 6.527986777753928e+20, 0] [-1.3055973555507857e+21, 2.1759955925846427e+21, 0] [-4.3519911851692854e+21, 7.253318641948809e+21, 0] [-1.4506637283897618e+22, 2.417772880649603e+22, 0] [-4.835545761299206e+22, 8.059242935498677e+22, 0] [-1.6118485870997353e+23, 2.6864143118328925e+23, 0] [-5.372828623665785e+23, 8.954714372776308e+23, 0] [-1.7909428745552617e+24, 2.984904790925436e+24, 0] [-5.969809581850872e+24, 9.94968263641812e+24, 0] [-1.989936527283624e+25, 3.3165608788060404e+25, 0] [-6.633121757612081e+25, 1.1055202929353469e+26, 0] [-2.2110405858706938e+26, 3.685067643117823e+26, 0] [-7.370135286235646e+26, 1.2283558810392744e+27, 0] [-2.4567117620785488e+27, 4.094519603464248e+27, 0] [-8.189039206928496e+27, 1.364839867821416e+28, 0] [-2.729679735642832e+28, 4.549466226071387e+28, 0] [-9.098932452142774e+28, 1.5164887420237957e+29, 0] [-3.0329774840475915e+29, 5.054962473412652e+29, 0] [-1.0109924946825304e+30, 1.6849874911375506e+30, 0] [-3.3699749822751013e+30, 5.616624970458502e+30, 0] [-1.1233249940917004e+31, 1.8722083234861674e+31, 0] [-3.7444166469723348e+31, 6.240694411620558e+31, 0] [-1.2481388823241117e+32, 2.0802314705401862e+32, 0] [-4.1604629410803725e+32, 6.934104901800621e+32, 0] [-1.3868209803601242e+33, 2.311368300600207e+33, 0] [-4.622736601200414e+33, 7.704561002000691e+33, 0] [-1.5409122004001381e+34, 2.568187000666897e+34, 0] [-5.136374001333794e+34, 8.560623335556324e+34, 0] [-1.712124667111265e+35, 2.853541111852108e+35, 0] [-5.707082223704216e+35, 9.511803706173693e+35, 0] [-1.9023607412347386e+36, 3.170601235391231e+36, 0] [-6.341202470782462e+36, 1.0568670784637437e+37, 0] [-2.1137341569274874e+37, 3.5228902615458124e+37, 0] [-7.045780523091625e+37, 1.1742967538486043e+38, 0] [-2.3485935076972086e+38, 3.914322512828681e+38, 0] [-7.828645025657362e+38, 1.3047741709428937e+39, 0] [-2.6095483418857873e+39, 4.349247236476312e+39, 0] [-8.698494472952624e+39, 1.4497490788254373e+40, 0] [-2.8994981576508745e+40, 4.832496929418125e+40, 0] [-9.66499385883625e+40, 1.6108323098060416e+41, 0] [-3.221664619612083e+41, 5.369441032686805e+41, 0] [-1.073888206537361e+42, 1.789813677562268e+42, 0] [-3.579627355124536e+42, 5.966045591874227e+42, 0] [-1.1932091183748453e+43, 1.9886818639580756e+43, 0] [-3.977363727916151e+43, 6.628939546526918e+43, 0] [-1.3257879093053837e+44, 2.209646515508973e+44, 0] [-4.419293031017946e+44, 7.365488385029909e+44, 0] [-1.4730976770059818e+45, 2.4551627950099695e+45, 0] [-4.910325590019939e+45, 8.183875983366565e+45, 0] [-1.636775196673313e+46, 2.727958661122189e+46, 0] [-5.455917322244377e+46, 9.093195537073962e+46, 0] [-1.8186391074147924e+47, 3.0310651790246545e+47, 0] [-6.062130358049309e+47, 1.0103550596748849e+48, 0] [-2.0207101193497698e+48, 3.3678501989162833e+48, 0] [-6.735700397832567e+48, 1.1226167329720944e+49, 0] [-2.245233465944189e+49, 3.742055776573648e+49, 0] [-7.484111553147296e+49, 1.2473519255245493e+50, 0] 2.4947038510490986e+50, 4.1578397517484975e+50, 0] [-8.315679503496995e+50, 1.385946583916166e+51, 0]","title":"3. MATERI 3"},{"location":"3. MATERI 3/#metode-gauss-jordan","text":"","title":"METODE GAUSS JORDAN"},{"location":"3. MATERI 3/#pengertian","text":"Metode Gauss-Jordan merupakan suatu variasi dari Eliminasi Gauss dan dalam bahasa analitik biasanya lebih dikenal dengan nama reduksi baris. Perbedaan utamanya dengan eliminasi Gauss adalah bila sebuah yang tidak diketahui dieliminasikan dengan metode Gauss-Jordan maka ia deliminasikan dari setiap persamaan lainnya. Ini merupakan bentuk matrik kesatuan,padahal eliminasi Gauss merupakan matrik triangular.","title":"PENGERTIAN"},{"location":"3. MATERI 3/#dasar-teori","text":"Penambahan Matrik sebelah kiri diubah menjadi matrik diagonal Penyelesaian dari persamaan linier simultan diatas adalah nilai d1,d2,d3,\u2026,dn dan atau x1 = d1,x2 = d2,x3=d3,\u2026.,xn=dn Teknik yang digunakan dalam metode eliminasi Gauss-Jordan ini sama seperti metode eliminasi Gauss yaitu menggunakan OBE (Operasi Baris Elementer). Hanya perhitungan penyelesaian secara langsung diperoleh dari nilai pada kolom terakhir dari setiap baris . Satu cara yang gamblang untuk menghitung inversi ialah dengan menggunakan metode Gauss-Jordan. Untuk melakukan ini,matriks koefisien diperluas dengan sebuah matriks kesatuan. Kemudian metode Gauss Jordan diterapkan agar mengurangi matriks koefisien menjadi sebuah matriks kesatuan. Jika ini telah selesai, ruas kanan matriks yang diperluas akan mengandung inversi","title":"DASAR TEORI"},{"location":"3. MATERI 3/#contoh","text":"\u2022Selesaikan sistem persamaan :","title":"CONTOH"},{"location":"3. MATERI 3/#program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) A.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) B.append(h) Matrix=np.array(A,float) Hasil=np.array(B,float) n=len(Matrix) #Eliminasi Gauss for k in range(0,n-1): for i in range(k+1,n): if Matrix[i,k]!=0 : lam=Matrix[i,k]/Matrix[k,k] Matrix[i,k:n]=Matrix[i,k:n]-(Matrix[k,k:n]*lam) Hasil[i]=Hasil[i]-(Hasil[k]*lam) print(\"Matrix A : \",'\\n',Matrix) #Subtitution x=np.zeros(n,float) for m in range(n-1,-1,-1): x[m]=(Hasil[m]-np.dot(Matrix[m, m+1:n], x[m+1:n]))/Matrix[m,m] print('Nilai X ',m+1, '=',x[m]) hasil Run : Hasil 1: Masukkan ukuran Matrix: 3 Masukkan Nilai: 1 Masukkan Nilai: 1 Masukkan Nilai: 1 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 2 Masukkan Nilai: 2 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Hasil: 6 Masukkan Hasil: 2 Masukkan Hasil: 3 Matrix A : [[ 1. 1. 1. ] [ 0. -2. 1. ] [ 0. 0. -3.5]] Nilai X 3 = 2.0 Nilai X 2 = 3.0 Nilai X 1 = 1.0","title":"PROGRAM"},{"location":"3. MATERI 3/#metode-jacob","text":"","title":"METODE JACOB"},{"location":"3. MATERI 3/#pengertian_1","text":"Metode [Iterasi] Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan persamaan linear dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan [persamaan linear] berukuran besar dan proporsi koefisien nolnya besar. Kalau kita mengubah dalam Sistem Persamaan Linear, maka dapat ditulis sebagai berikut: Ax=b Kemudian, diketahui bahwa A =D + (L + U), di mana D merupakan matriks diagonal, L merupakan matriks segitiga bawah, dan U merupakan matriks segitiga atas. Kemudian, persamaan di atas dapat diubah menjadi: Dx + (L + U)x=b Kemudian, \u00d7 = D \u0304 \u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] Jika ditulis dalam aturan iteratif, maka metode Jacobi dapat ditulis sebagai: \u00d7\u207d\u1d4f\u207a\u00b9\u207e = D \u0304\u00b9[b-( L + U )\u00d7\u207d\u1d4f\u207e] di mana k merupakan banyaknya iterasi. Jika \u00d7\u207d\u1d4f\u207e menyatakan hampiran ke-k penyelesaian SPL, maka \u00d7\u207d\u2070\u207e adalah hampiran awal.","title":"PENGERTIAN"},{"location":"3. MATERI 3/#program_1","text":"from pprint import pprint from numpy import array, zeros, diag, diagflat, dot import numpy as np def jacobi(A,b,N=25,x=None): #Membuat iniial guess if x is None: x = zeros(len(A[0])) #Membuat vektor dari elemen matrix A D = diag(A) R = A - diagflat(D) #Iterasi for i in range(N): x = (b - dot(R,x)) / D return x Mat1 = [] Mat2 = [] n = int(input(\"Masukkan ukuran Matrix: \")) for i in range(n): baris=[] for i in range(n): a=int(input(\"Masukkan Nilai: \")) baris.append(a) Mat1.append(baris) for i in range(n): h = int(input(\"Masukkan Hasil: \")) Mat2.append(h) A = array(Mat1,float) b = array(Mat2,float) x=len(Mat1) guess = np.zeros(x,float) sol = jacobi(A,b,N=25,x=guess) print(\"A:\") pprint(A) print(\"b:\") pprint(b) print(\"x:\") pprint(sol) HASI RUN contoh 1: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 3 Masukkan Nilai: 5 Masukkan Nilai: 7 Masukkan Nilai: 3 Masukkan Nilai: 5 Masukkan Nilai: 6 Masukkan Nilai: 3 Masukkan Hasil: 20 Masukkan Hasil: 18 Masukkan Hasil: 30 A: array([[2., 4., 3.], [5., 7., 3.], [5., 6., 3.]]) b: array([20., 18., 30.]) x: array([2.06506309e+10, 9.61264713e+09, 2.15123264e+10]) Cotoh 2: Masukkan ukuran Matrix: 2 Masukkan Nilai: 3 Masukkan Nilai: 6 Masukkan Nilai: 3 Masukkan Nilai: 8 Masukkan Hasil: 9 Masukkan Hasil: 16 A: array([[3., 6.], [3., 8.]]) b: array([ 9., 16.]) x: array([-3.77826554, 3.45248547])","title":"PROGRAM"},{"location":"3. MATERI 3/#metode-gauss-seidel","text":"","title":"METODE GAUSS SEIDEL"},{"location":"3. MATERI 3/#pengertian_2","text":"Eliminasi Gauss seidel adalah metode yang menggunakan proses iterasi hingga diperoleh nilai nilai yang berubah. Bilai diketahui peramaan linier simultan:","title":"PENGERTIAN"},{"location":"3. MATERI 3/#konsep-metode-gauss-seidel","text":"Hitung nilai xi untuk (i = 1 s/d n)","title":"KONSEP METODE GAUSS SEIDEL"},{"location":"3. MATERI 3/#algoritma-metode-gauss-seidel","text":"Masukkan matrik A , dan vektor B beserta ukuranya n. tentukan batas maksimum iterasi max_iter tentukkan toleransi error. tentukan nilai awal dari xi, untuk i =1 s/d n simpan xi dalam si, untuk i=1 s/d n untuk i=1 s/d n hitung iterasi <- iterasi +1 bila iterasi lebih dari max_iter atau tidak terdapat ei<\u03f5 untuk i=1 s/d n maka proses dihentikan dari penyelesaianya adalah xi untuk i=1 s/d n. Bila tidak maka ulangi langkah (5).","title":"ALGORITMA METODE GAUSS SEIDEL"},{"location":"3. MATERI 3/#program_2","text":"def seidel(a, x ,b): #Mencari Panjang Matrix n = len(a) for j in range(0, n): d = b[j] #Menghitung xi, yi, zi for i in range(0, n): if(j != i): d-=a[j][i] * x[i] x[j] = d / a[j][j] #Solusi return x m=int(input(\"Masukkan Panjang Matrix: \")) a=[] b=[] for k in range(m): mat1=[] for i in range(m): l=float(input(\"Masukkan a\"+str(k+1)+\",\"+str(i+1)+\": \")) mat1.append(l) h=float(input(\"Masukkan Hasil: \")) b.append(h) a.append(mat1) n = 3 x = [0, 0, 0] print(x) for i in range(0, 100): x = seidel(a, x, b) #print each time the updated solution print(x) Masukkan Panjang Matrix: 2 Masukkan a1,1: 2 Masukkan a1,2: 4 Masukkan Hasil: 3 Masukkan a2,1: 5 Masukkan a2,2: 3 Masukkan Hasil: 8 [0, 0, 0] [1.5, 0.16666666666666666, 0] [1.1666666666666667, 0.722222222222222, 0] [0.055555555555556024, 2.574074074074073, 0] [-3.648148148148146, 8.74691358024691, 0] [-15.993827160493819, 29.3230452674897, 0] [-57.1460905349794, 97.91015089163233, 0] [-194.32030178326465, 326.53383630544107, 0] [-651.5676726108821, 1088.6127876848036, 0] [-2175.725575369607, 3628.8759589493457, 0] [-7256.251917898691, 12096.419863164485, 0] [-24191.33972632897, 40321.566210548284, 0] [-80641.63242109657, 134405.38736849427, 0] [-268809.27473698853, 448018.1245616476, 0] [-896034.7491232952, 1493393.915205492, 0] [-2986786.330410984, 4977979.884018307, 0] [-9955958.268036613, 16593266.446727687, 0] [-33186531.393455375, 55310888.322425626, 0] [-110621775.14485125, 184369627.90808544, 0] [-368739254.3161709, 614565426.5269514, 0] [-1229130851.5539029, 2048551421.9231713, 0] [-4097102842.3463426, 6828504739.910571, 0] [-13657009478.321142, 22761682466.535236, 0] [-45523364931.57047, 75872274888.61745, 0] [-151744549775.7349, 252907582962.22482, 0] [-505815165922.94965, 843025276540.916, 0] [-1686050553080.332, 2810084255136.553, 0] [-5620168510271.606, 9366947517122.01, 0] [-18733895034242.52, 31223158390406.863, 0] [-62446316780812.23, 104077194634689.7, 0] [-208154389269377.9, 346923982115632.5, 0] [-693847964231263.5, 1156413273718775.2, 0] [-2312826547437549.0, 3854710912395917.5, 0] [-7709421824791834.0, 1.2849036374653058e+16, 0] [-2.5698072749306116e+16, 4.283012124884353e+16, 0] [-8.566024249768706e+16, 1.4276707082947842e+17, 0] [-2.8553414165895683e+17, 4.7589023609826144e+17, 0] [-9.517804721965229e+17, 1.5863007869942047e+18, 0] [-3.1726015739884093e+18, 5.287669289980682e+18, 0] [-1.0575338579961364e+19, 1.7625564299935607e+19, 0] [-3.5251128599871214e+19, 5.875188099978536e+19, 0] [-1.1750376199957071e+20, 1.9583960333261786e+20, 0] [-3.916792066652357e+20, 6.527986777753928e+20, 0] [-1.3055973555507857e+21, 2.1759955925846427e+21, 0] [-4.3519911851692854e+21, 7.253318641948809e+21, 0] [-1.4506637283897618e+22, 2.417772880649603e+22, 0] [-4.835545761299206e+22, 8.059242935498677e+22, 0] [-1.6118485870997353e+23, 2.6864143118328925e+23, 0] [-5.372828623665785e+23, 8.954714372776308e+23, 0] [-1.7909428745552617e+24, 2.984904790925436e+24, 0] [-5.969809581850872e+24, 9.94968263641812e+24, 0] [-1.989936527283624e+25, 3.3165608788060404e+25, 0] [-6.633121757612081e+25, 1.1055202929353469e+26, 0] [-2.2110405858706938e+26, 3.685067643117823e+26, 0] [-7.370135286235646e+26, 1.2283558810392744e+27, 0] [-2.4567117620785488e+27, 4.094519603464248e+27, 0] [-8.189039206928496e+27, 1.364839867821416e+28, 0] [-2.729679735642832e+28, 4.549466226071387e+28, 0] [-9.098932452142774e+28, 1.5164887420237957e+29, 0] [-3.0329774840475915e+29, 5.054962473412652e+29, 0] [-1.0109924946825304e+30, 1.6849874911375506e+30, 0] [-3.3699749822751013e+30, 5.616624970458502e+30, 0] [-1.1233249940917004e+31, 1.8722083234861674e+31, 0] [-3.7444166469723348e+31, 6.240694411620558e+31, 0] [-1.2481388823241117e+32, 2.0802314705401862e+32, 0] [-4.1604629410803725e+32, 6.934104901800621e+32, 0] [-1.3868209803601242e+33, 2.311368300600207e+33, 0] [-4.622736601200414e+33, 7.704561002000691e+33, 0] [-1.5409122004001381e+34, 2.568187000666897e+34, 0] [-5.136374001333794e+34, 8.560623335556324e+34, 0] [-1.712124667111265e+35, 2.853541111852108e+35, 0] [-5.707082223704216e+35, 9.511803706173693e+35, 0] [-1.9023607412347386e+36, 3.170601235391231e+36, 0] [-6.341202470782462e+36, 1.0568670784637437e+37, 0] [-2.1137341569274874e+37, 3.5228902615458124e+37, 0] [-7.045780523091625e+37, 1.1742967538486043e+38, 0] [-2.3485935076972086e+38, 3.914322512828681e+38, 0] [-7.828645025657362e+38, 1.3047741709428937e+39, 0] [-2.6095483418857873e+39, 4.349247236476312e+39, 0] [-8.698494472952624e+39, 1.4497490788254373e+40, 0] [-2.8994981576508745e+40, 4.832496929418125e+40, 0] [-9.66499385883625e+40, 1.6108323098060416e+41, 0] [-3.221664619612083e+41, 5.369441032686805e+41, 0] [-1.073888206537361e+42, 1.789813677562268e+42, 0] [-3.579627355124536e+42, 5.966045591874227e+42, 0] [-1.1932091183748453e+43, 1.9886818639580756e+43, 0] [-3.977363727916151e+43, 6.628939546526918e+43, 0] [-1.3257879093053837e+44, 2.209646515508973e+44, 0] [-4.419293031017946e+44, 7.365488385029909e+44, 0] [-1.4730976770059818e+45, 2.4551627950099695e+45, 0] [-4.910325590019939e+45, 8.183875983366565e+45, 0] [-1.636775196673313e+46, 2.727958661122189e+46, 0] [-5.455917322244377e+46, 9.093195537073962e+46, 0] [-1.8186391074147924e+47, 3.0310651790246545e+47, 0] [-6.062130358049309e+47, 1.0103550596748849e+48, 0] [-2.0207101193497698e+48, 3.3678501989162833e+48, 0] [-6.735700397832567e+48, 1.1226167329720944e+49, 0] [-2.245233465944189e+49, 3.742055776573648e+49, 0] [-7.484111553147296e+49, 1.2473519255245493e+50, 0] 2.4947038510490986e+50, 4.1578397517484975e+50, 0] [-8.315679503496995e+50, 1.385946583916166e+51, 0]","title":"PROGRAM"},{"location":"4. recursive trapezoid/","text":"Pengertian Trapesium Rekursif merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann.Selanjutnya,menurut Teorema Dasar Kalkulusintegral tersebut dapat dihitung dengan rumus, Dengan F(x) adalah antiderivatif f(x) (yakni F\u2019(x)=f(x) ). Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Integrasi numerik merupakan suatu alat utama yang digunakan para ilmuwan untuk mendapatkan nilai-nilai hampiran untuk integral tentu yang tidak dapat diselesaikan secara analitik. Dalam mendapatkan nilai-nilai hampiran integral tentu, digunakan banyak metode, salah satu metode yang dapat digunakan adalah Aturan Trapesium Rekursif. code program def fungsi (x) : y = 1/(1+x) return y print(\"f(x) = 1/(1+x)\") a = float(input(\"Masukkan batas bawah integral : \")) b = float(input(\"Masukkan batas atas integral : \")) print(\"iterasi\",\"n\",\"trapesium\") for iterasi in range (1,16,1): n=2*iterasi h=(b-a)/n xi = a y = 0 for i in range(1,n): xi = xi+h y += fungsi(xi) hasil = (h)*((fungsi(a)+(2*y)+fungsi(b))/2) print (iterasi,n,hasil) Ouput : f(x) = 1/(1+x) Masukkan batas bawah integral : 2 Masukkan batas atas integral : 3 iterasi n trapesium 1 2 0.28869047619047616 2 4 0.2879349816849817 3 6 0.28779454400163784 4 8 0.2877453510163465 5 10 0.2877225746826515 6 12 0.28771020049170193 7 14 0.2877027386110822 8 16 0.28769789530831674 9 18 0.28769457463975956 10 20 0.2876921993271122 11 22 0.2876904418332646 12 24 0.2876891050973386 13 26 0.2876880647918689 14 28 0.2876872393347254 15 30 0.2876865733937683","title":"4. recursive trapezoid"},{"location":"4. recursive trapezoid/#pengertian","text":"Trapesium Rekursif merupakan suatu metode pengintegralan dalam analisis numerik.di dalam Kalkulus, integral tentu didefinisikan sebagai sebuah limit jumlah Riemann.Selanjutnya,menurut Teorema Dasar Kalkulusintegral tersebut dapat dihitung dengan rumus, Dengan F(x) adalah antiderivatif f(x) (yakni F\u2019(x)=f(x) ). Banyak integral tentu yang dapat dihitung dengan rumus tesebut, namun demikian, tidak sedikit integral tentu yang tidak dapat dihitung dengan rumus di atas, hal itu dikarenakan integran f(x) tidak mempunyai antiderivatif yang dapat dinyatakan dalam fungsi-fungsi elementer. Dalam hal ini perhitungan yang dapat dilakukan adalah secara numerik. Integrasi numerik merupakan suatu alat utama yang digunakan para ilmuwan untuk mendapatkan nilai-nilai hampiran untuk integral tentu yang tidak dapat diselesaikan secara analitik. Dalam mendapatkan nilai-nilai hampiran integral tentu, digunakan banyak metode, salah satu metode yang dapat digunakan adalah Aturan Trapesium Rekursif.","title":"Pengertian"},{"location":"4. recursive trapezoid/#code-program","text":"def fungsi (x) : y = 1/(1+x) return y print(\"f(x) = 1/(1+x)\") a = float(input(\"Masukkan batas bawah integral : \")) b = float(input(\"Masukkan batas atas integral : \")) print(\"iterasi\",\"n\",\"trapesium\") for iterasi in range (1,16,1): n=2*iterasi h=(b-a)/n xi = a y = 0 for i in range(1,n): xi = xi+h y += fungsi(xi) hasil = (h)*((fungsi(a)+(2*y)+fungsi(b))/2) print (iterasi,n,hasil) Ouput : f(x) = 1/(1+x) Masukkan batas bawah integral : 2 Masukkan batas atas integral : 3 iterasi n trapesium 1 2 0.28869047619047616 2 4 0.2879349816849817 3 6 0.28779454400163784 4 8 0.2877453510163465 5 10 0.2877225746826515 6 12 0.28771020049170193 7 14 0.2877027386110822 8 16 0.28769789530831674 9 18 0.28769457463975956 10 20 0.2876921993271122 11 22 0.2876904418332646 12 24 0.2876891050973386 13 26 0.2876880647918689 14 28 0.2876872393347254 15 30 0.2876865733937683","title":"code program"},{"location":"5. Richardson Extrapolation/","text":"PENGERTIAN Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Beda terpusat (Central Difference): Dapat kita mendapat formula terbaik ? Ditetapkan f (x) dan x tertentu: TUGAS \u2022 Gunakan fungsi: f(x)=\u22120.1x4\u22120.15x3\u22120.5x2\u22120.25x+1.2f(x)=\u22120.1x4\u22120.15x3\u22120.5x2\u22120.25x+1.2 Mulai dari h1=0.5 dan h2=0.25 hitung estimasi dengan f'(0.5) menggunakan richardson Extrapolation \u2022 nilai sesungguhnya f'(0.5)=\u22120.9125 SOLUSI : Turunan pertama dapat dihitung dengan beda terpusat ( centered differences) yaitu: Estimasi dapat di perbaiki dengan menggunakan : yang menghasilkan nilai yang sama TABLE D(0,0) = \u00d8 (h) D(1,0) =\u00d8(h/2) D(1,1) D(2,0)=\u00d8(h/4) D(2,1) D(2,2) D(3,0)=\u00d8(h/8) D(3,1) D(3,2) D(3,3) PROGRAM from math import * def nol(n,m): # matrik nol untuk lokasi awal Z=[] for i in range(n): Z.append([0]*m) return Z def D(fungsi,a,h): # pergbedaan terbatas terpusat dengan ukuran langkah h pada x=a return (fungsi(a+h)-fungsi(a-h))/(2*h) def Richardson_dif(fung,a): '''Metode extrapolasi Richartdson untuk menghitung numerik turunan pertama ''' k=9 # Kamnu dapat merubah rutan aproksimasi tetapi usahakan dibawah 10 untuk menghindari kesalahan pembulatan. L=nol(k,k) for I in range(k): L[I][0]=D(fung,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('diferensiasi numerik dari Funsi 1=-0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 at x=0.5') print (\" \") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\" \") print('diff(2**cos(pi+sin(x)) at x=pi/2 is equal to = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) RUN diferensiasi numerik dari Funsi 1=-0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 at x=0.5 Hasil dari fungsi di atas = -0.91250000000000530687 diff(2**cos(pi+sin(x)) at x=pi/2 is equal to = 0.16849558398154249050","title":"5. Richardson Extrapolation"},{"location":"5. Richardson Extrapolation/#pengertian","text":"Richardson Extrapolation adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Richardson Extrapolation termasuk integrasi Romberg, yang menerapkan ekstrapolasi Richardson pada aturan trapesium, dan algoritma Bulirsch-Stoer untuk menyelesaikan persamaan diferensial biasa. Beda terpusat (Central Difference): Dapat kita mendapat formula terbaik ? Ditetapkan f (x) dan x tertentu:","title":"PENGERTIAN"},{"location":"5. Richardson Extrapolation/#tugas","text":"\u2022 Gunakan fungsi: f(x)=\u22120.1x4\u22120.15x3\u22120.5x2\u22120.25x+1.2f(x)=\u22120.1x4\u22120.15x3\u22120.5x2\u22120.25x+1.2 Mulai dari h1=0.5 dan h2=0.25 hitung estimasi dengan f'(0.5) menggunakan richardson Extrapolation \u2022 nilai sesungguhnya f'(0.5)=\u22120.9125 SOLUSI : Turunan pertama dapat dihitung dengan beda terpusat ( centered differences) yaitu: Estimasi dapat di perbaiki dengan menggunakan : yang menghasilkan nilai yang sama TABLE D(0,0) = \u00d8 (h) D(1,0) =\u00d8(h/2) D(1,1) D(2,0)=\u00d8(h/4) D(2,1) D(2,2) D(3,0)=\u00d8(h/8) D(3,1) D(3,2) D(3,3)","title":"TUGAS"},{"location":"5. Richardson Extrapolation/#program","text":"from math import * def nol(n,m): # matrik nol untuk lokasi awal Z=[] for i in range(n): Z.append([0]*m) return Z def D(fungsi,a,h): # pergbedaan terbatas terpusat dengan ukuran langkah h pada x=a return (fungsi(a+h)-fungsi(a-h))/(2*h) def Richardson_dif(fung,a): '''Metode extrapolasi Richartdson untuk menghitung numerik turunan pertama ''' k=9 # Kamnu dapat merubah rutan aproksimasi tetapi usahakan dibawah 10 untuk menghindari kesalahan pembulatan. L=nol(k,k) for I in range(k): L[I][0]=D(fung,a,1/(2**(I+1))) for j in range(1,k): for i in range(k-j): L[i][j]=((4**(j))*L[i+1][j-1]-L[i][j-1])/(4**(j)-1) return L[0][k-1] print('diferensiasi numerik dari Funsi 1=-0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 at x=0.5') print (\" \") print('%04.20f'%Richardson_dif(lambda x: -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 ,0.5)) print(\" \") print('diff(2**cos(pi+sin(x)) at x=pi/2 is equal to = %04.20f'%Richardson_dif(lambda x: 2**cos(pi+sin(x)),pi/3)) RUN diferensiasi numerik dari Funsi 1=-0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 at x=0.5 Hasil dari fungsi di atas = -0.91250000000000530687 diff(2**cos(pi+sin(x)) at x=pi/2 is equal to = 0.16849558398154249050","title":"PROGRAM"},{"location":"6. EULER/","text":"PENGERTIAN Persamaan diferensil biasa orde satu dapat diselesaikan dengan berbagai macam metode numerik. Salah satu metode yang cukup terkenal adalah metode Euler. Metode ini ditemukan oleh Leonhard Euler pada tahun 1770. Anggap ada sebuah persamaan diferential biasa orde satu dan kondisi awal dengan persamaan sebagai berikut. Dengan \u201cLangkah\u201d h didefinisikan sebagai Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis TUGAS Gunakan metode Euler untuk menyelesaikan PDB: Untuk menentukan y(1.01), y(1.02) dan y(1.03). PROGRAM import numpy as np def f(x,y): f = -0.05*(y-20) print(f) return f ##Parameter untuk Euler y0 = -4 xf = float(input(\"masukkan nilai xf :\")) n = 4 h = 1.01-xf y = 0 hasil = y0 ##metode Euler for i in range(1,n): hasil = y0 + h*(1+(xf+y)**2) y+=h yo=hasil print(\"hasil dari y\"+str(i)+\"= \"+ str(hasil)) RUN : masukkan nilai x1 :1 hasil dari y1= -3.98 hasil dari y2= -3.979799 hasil dari y3= -3.979596 >>>","title":"6. EULER"},{"location":"6. EULER/#pengertian","text":"Persamaan diferensil biasa orde satu dapat diselesaikan dengan berbagai macam metode numerik. Salah satu metode yang cukup terkenal adalah metode Euler. Metode ini ditemukan oleh Leonhard Euler pada tahun 1770. Anggap ada sebuah persamaan diferential biasa orde satu dan kondisi awal dengan persamaan sebagai berikut. Dengan \u201cLangkah\u201d h didefinisikan sebagai Persamaan Euler untuk menyelesaikan persamaan diferensial biasa orde 1 dapat ditulis","title":"PENGERTIAN"},{"location":"6. EULER/#tugas","text":"Gunakan metode Euler untuk menyelesaikan PDB: Untuk menentukan y(1.01), y(1.02) dan y(1.03).","title":"TUGAS"},{"location":"6. EULER/#program","text":"import numpy as np def f(x,y): f = -0.05*(y-20) print(f) return f ##Parameter untuk Euler y0 = -4 xf = float(input(\"masukkan nilai xf :\")) n = 4 h = 1.01-xf y = 0 hasil = y0 ##metode Euler for i in range(1,n): hasil = y0 + h*(1+(xf+y)**2) y+=h yo=hasil print(\"hasil dari y\"+str(i)+\"= \"+ str(hasil)) RUN : masukkan nilai x1 :1 hasil dari y1= -3.98 hasil dari y2= -3.979799 hasil dari y3= -3.979596 >>>","title":"PROGRAM"}]}